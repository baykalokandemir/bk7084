# Functionality and Implementation Details

This document explains the implementation of the city and building generation features exposed in the `step_by_step_city.py` and `building_test.py` demonstrations.

---

## Part 1: Street Generation
(Demonstrated in `exercises/step_by_step_city.py`)

The street generation pipeline transforms a root area into a structured network of roads, blocks, and infrastructure using recursive subdivision and procedural geometry.

### 1. Parameters
- **City Size (Width/Depth)**: Defines the dimensions of the initial root logic polygon (rectangle).
- **Split Blocks**: Enables the recursive binary space partitioning (BSP) algorithm.
- **Diagonals**: Controls the angle selection strategy during splitting.
- **Center Hexagon**: Injecting a specific geometric feature (Town Square) before general splitting.

### 2. Implementation Logic

#### A. Block Splitting (`_split_city_recursive`)
The city layout is generated by recursively splitting a polygon (initially the entire city bounds).
- **Algorithm**:
  1.  Calculate the Oriented Bounding Box (OBB) of the current polygon to find its center and primary axes.
  2.  Select a random **split point** near the center (with some jitter).
  3.  Select a **split direction** (angle).
      - If **Diagonals** are *Disabled*: The angle is snapped to 0 or 90 degrees based on the aspect ratio (split the longest side).
      - If **Diagonals** are *Enabled* (and `ortho_chance` check fails): A random angle between 0 and 2*PI is chosen.
  4.  The polygon is sliced into two children using the `poly.split(point, dir)` method.
  5.  **Road Insertion**: A road segment is added to the `RoadNetwork` along the split line where it intersects the polygon. The width of the road depends on the recursion depth (Main arteries are wider, local streets are narrower).
  6.  Recursion continues until the `min_block_area` is reached.

#### B. Town Square (`_create_town_square`)
This is a constructive geometry step performed *before* recursive splitting.
- **Logic**: A hexagon (or n-gon) is defined at the center of the root polygon.
- **Subtraction**: The center polygon is "cut" out of the root polygon by successively splitting the root with lines corresponding to the hexagon's edges.
- **Network Integration**: The edges of the hexagon are added as road segments to the `RoadNetwork`, creating a ring road. Radial "spokes" are also added connecting the corners to the outer boundary.

#### C. Road Mesh Generation (`RoadNetwork.generate_meshes`)
The `RoadNetwork` class converts the abstract graph of segments (nodes and edges) into 3D geometry.
- **Intersections**: The system identifies nodes with multiple connections. It calculates the corner points where incoming roads meet.
- **Geometry construction**: 
    - **Intersections**: Generated as polygon fans filling the space between road corners.
    - **Road Segments**: generated as quads connecting the corners of two adjacent intersections.
- **Layering**: Roads are generated at slightly different Y-heights (0.050 - 0.055) based on their lane count to avoid z-fighting overlap, with wider roads rendering on top.

#### D. Sidewalks and Block Shrinking
- **Logic**: The "raw blocks" resulting from the split process represent the space *between* road centerlines.
- **Inset**: To create space for the actual road width and the sidewalk:
  1.  `curb_poly = raw_block.inset(3.0)`: Defines the outer edge of the sidewalk (curb).
  2.  `building_lot = curb_poly.inset(2.0)`: Defines the inner edge (property line).
- **Mesh**: A "ring" mesh is generated between `curb_poly` and `building_lot`, extruded slightly upwards (y=0.2) to act as the sidewalk.

#### E. Street Lamps
- **Placement**: The system iterates over the *edges* of the generated road meshes.
- **Logic**: Lamps are placed at regular intervals (`25.0` units).
- **Orientation**: 
  - Position is calculated along the edge vector.
  - Rotation is calculated so the lamp faces the road (using the cross product of the edge normal and up vector).
- **Culling**: In the main loop, a dynamic culling system sorts all lamps by distance to the camera and only activates the closest 8 `PointLights` to maintain performance.

---

## Part 2: Building Generation
(Demonstrated in `exercises/building_test.py`)

Buildings are procedurally generated from using the `Building` class, which supports various styles and geometries.

### 1. Functionalities & Implementation

#### A. Footprint Generation
- **Logic**: A convex polygon is generated by perturbing the vertices of a rectangle. This ensures buildings can adapt to irregular lots resulting from the diagonal city splitting.

#### B. Height
- **Implementation**: A direct parameter controlling the Y-extrusion limit of the geometry.

#### C. Corners (`Chamfer`, `Fillet`)
Before extrusion, the 2D footprint polygon is modified:
- **Sharp**: Unmodified polygon.
- **Chamfered**: `poly.chamfer(radius)` replaces each vertex with two new vertices along the adjacent edges, creating a cut corner.
- **Rounded**: `poly.fillet(radius)` replaces each vertex with a series of vertices following a quadratic Bezier curve, approximating a round corner.

#### D. Windows (Facade slicing)
The facade generation logic in `_generate_block` creates detailed geometry rather than using textures.
- **Logic**: For each wall (edge of the polygon):
  1.  **Columns**: 15% of the wall width at corners is reserved for solid columns.
  2.  **Slicing**: The remaining central area is sliced horizontally into floors (`floor_height`).
  3.  **Pattern**: 
      - **Wide**: A single large window per floor.
      - **Narrow**: The wall is sliced vertically into strips (`window + gap`), creating multiple windows.
  4.  **Geometry**: For each window, the system generates quads for the sill, header, and frame.
  5.  **Inset**: The glass quad is pushed inwards (negative normal direction) by `0.5` units to create depth.

#### E. Stepped (Tiered) Architecture
- **Implementation**: If enabled, the building is generated in 3 stacked tiers instead of one solid block.
  - **Tier 1**: Base footprint, 50% height.
  - **Tier 2**: `footprint.scale(0.7)`, 30% height, stacked on Tier 1.
  - **Tier 3**: `footprint.scale(0.4)`, 20% height, stacked on Tier 2.
- **Logic**: This reuses the `_generate_block` function for each tier, ensuring consistent window styles across the uneven volumes.

#### F. Antenna
- **Implementation**: A logical post-process step. A simple pole mesh (extruded small square) is generated at the centroid of the building's top face.
